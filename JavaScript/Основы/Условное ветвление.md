Условное ветвление возможно в javascript благодаря инструкции `if` и условному оператору `?`, который также называют оператором «вопросительный знак».

# Инструкция «if»
Инструкция `if(...)` вычисляет условие в скобках и, если результат `true`, то выполняет блок кода.
```js
let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

if (year == 2015) alert( 'Вы правы!' );
```
Если мы хотим выполнить более одной инструкции, то нужно заключить блок кода в фигурные скобки:
```javascript
if (year == 2015) {
	alert( "Правильно!" );
	alert( "Вы такой умный!" );
}
```
Рекомендуется использовать фигурные скобки `{}` всегда, когда вы используете инструкцию `if`, даже если выполняется только одна команда. Это улучшает читаемость кода.
## Преобразование к логическому типу
Инструкция `if (…)` вычисляет выражение в скобках и преобразует результат к логическому типу. [[Типы данных и преобразования#^012d4d]] 
- Число `0`, пустая строка `""`, `null`, `undefined` и `NaN` становятся `false`. Из-за этого их называют «ложными» («falsy») значениями.
- Остальные значения становятся `true`, поэтому их называют «правдивыми» («truthy»).
Таким образом, код при таком условии никогда не выполнится:
```js
if (0) { // 0 is falsy
  ...
}
```
…а при таком – выполнится всегда:
```js
if (1) { // 1 is truthy
  ...
}
```
Мы также можем передать заранее вычисленное в переменной логическое значение в `if`, например так:
```js 
let condition = (year == 2015); // преобразуется к true или false

if (condition) {
  ...
}
```
# Блок «else»
Инструкция `if` может содержать необязательный блок «else» («иначе»). Он выполняется, когда условие ложно.
```js
let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

if (year == 2015) {
  alert( 'Да вы знаток!' );
} else {
  alert( 'А вот и неправильно!' ); // любое значение, кроме 2015
}
```
# Несколько условий: «else if»
```js
let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

if (year < 2015) {
  alert( 'Это слишком рано...' );
} else if (year > 2015) {
  alert( 'Это поздновато' );
} else {
  alert( 'Верно!' );
}
```
В приведённом выше коде JavaScript сначала проверит `year < 2015`. Если это неверно, он переходит к следующему условию `year > 2015`. Если оно тоже ложно, тогда сработает последний `alert`.

Блоков `else if` может быть и больше. Присутствие блока `else` не является обязательным.
# Условный оператор „?“
Оператор представлен знаком вопроса `?`. Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента.
```js
let result = условие ? значение1 : значение2;
```
Пример
```js
let accessAllowed = (age > 18) ? true : false;
```
> [!NOTE] На заметку:
> В примере выше вы можете избежать использования оператора вопросительного знака `?`, т.к. сравнение само по себе уже возвращает `true/false`:
> ```javascript
> // то же самое
> let accessAllowed = age > 18;
> ```

## Несколько операторов „?“
Последовательность операторов вопросительного знака `?` позволяет вернуть значение, которое зависит от более чем одного условия.
```js 
let age = prompt('Возраст?', 18);

let message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';

alert( message );
```
Вот как это выглядит при использовании `if..else`:
```javascript
if (age < 3) {
  message = 'Здравствуй, малыш!';
} else if (age < 18) {
  message = 'Привет!';
} else if (age < 100) {
  message = 'Здравствуйте!';
} else {
  message = 'Какой необычный возраст!';
}
```
## Нетрадиционное использование „?“
```js 
let company = prompt('Какая компания создала JavaScript?', '');

(company == 'Netscape') ?
   alert('Верно!') : alert('Неправильно.');
```
Здесь мы не присваиваем результат переменной. Вместо этого мы выполняем различный код в зависимости от условия.

**Не рекомендуется использовать оператор вопросительного знака таким образом.**
Несмотря на то, что такая запись короче, чем эквивалентная инструкция `if`, она хуже читается.
# Конструкция "switch"
Конструкция `switch` заменяет собой сразу несколько `if`.
## Синтаксис
Конструкция `switch` имеет один или более блок `case` и необязательный блок `default`.
Выглядит она так:
```js
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
```
- Переменная `x` проверяется на строгое равенство первому значению `value1`, затем второму `value2` и так далее.
- Если соответствие установлено – `switch` начинает выполняться от соответствующей директивы `case` и далее, до ближайшего `break` (или до конца `switch`).
- Если ни один `case` не совпал – выполняется (если есть) вариант `default`.

Пример использования `switch`:
```js
let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Маловато' );
    break;
  case 4:
    alert( 'В точку!' );
    break;
  case 5:
    alert( 'Перебор' );
    break;
  default:
    alert( "Нет таких значений" );
}
```

**Если `break` нет, то выполнение пойдёт ниже по следующим `case`, при этом остальные проверки игнорируются.**


> [!NOTE] Любое выражение может быть аргументом для `switch/case`
> И `switch` и `case` допускают любое выражение в качестве аргумента.
> Например:
> ```js
> let a = "1";
> let b = 0;
> 
> switch (+a) {
> 	case b + 1:
> 	    alert("Выполнится, т.к. значением +a будет 1, что в точности равно b+1");
> 	    break;
> 	 default:
> 		 alert("Это не выполнится");
> 		 }
>  ```
> В этом примере выражение `+a` вычисляется в `1`, что совпадает с выражением `b + 1` в `case`, и следовательно, код в этом блоке будет выполнен.
## Группировка «case»

Несколько вариантов case, использующих один код, можно группировать.

Для примера, выполним один и тот же код для case 3 и case 5, сгруппировав их:
```js
let a = 3;

switch (a) {
  case 4:
    alert('Правильно!');
    break;

  case 3: // (*) группируем оба case
  case 5:
    alert('Неправильно!');
    alert("Может вам посетить урок математики?");
    break;

  default:
    alert('Результат выглядит странновато. Честно.');
}
```
## Тип имеет значение
Нужно отметить, что проверка на равенство всегда строгая. Значения должны быть одного типа, чтобы выполнялось равенство.
```js
let arg = prompt("Введите число?");
switch (arg) {
  case '0':
  case '1':
    alert( 'Один или ноль' );
    break;

  case '2':
    alert( 'Два' );
    break;

  case 3:
    alert( 'Никогда не выполнится!' );
    break;
  default:
    alert( 'Неизвестное значение' );
}
```
1. Для `'0'` и `'1'` выполнится первый `alert`.
2. Для `'2'` – второй `alert`.
3. Но для `3`, результат выполнения `prompt` будет строка `"3"`, которая не соответствует строгому равенству `===` с числом `3`. Таким образом, мы имеем «мёртвый код» в `case 3`! Выполнится вариант `default`.