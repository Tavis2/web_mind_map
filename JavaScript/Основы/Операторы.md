# Базовые операторы, математика

## Основные термины
В JavaScript ***оператор*** — это элемент языка, который выполняет действие над одним или несколькими операндами (значениями, переменными, выражениями) и возвращает результат.

**_Операнд_** – то, к чему применяется оператор. Например, в умножении `5 * 2` есть два операнда: левый операнд равен `5`, а правый операнд равен `2`. Иногда их называют «аргументами» вместо «операндов».

**_Унарным_** называется оператор, который применяется к одному операнду.
```js
let x = 1;
x = -x;// -1, применили унарный минус
```

_Бинарным_ называется оператор, который применяется к двум операндам.
```js 
let x = 1, y = 3;
alert( y - x ); // 2, бинарный минус вычитает значения
```

*Тернарный* - оператор, применяемый к трём операндам:
```js
condition ? value1 : value2
```

## Математические операторы
Поддерживаются следующие математические операторы:
- Сложение `+`,
- Вычитание `-`,
- Умножение `*`,
- Деление `/`,
- Взятие остатка от деления `%`,
- Возведение в степень `**`.
## Сложение строк при помощи бинарного +
Если бинарный оператор '+' применить к строкам, то он их объединяет в одну:
```js 
let s = "моя" + "строка";
alert(s); // моястрока
```
Если хотя бы один операнд является строкой, то второй будет также преобразован в строку.
```js
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```

Оператор сложения действует последовательно, поэтому в примере ниже результат будет "41":
```js
alert(2 + 2 + '1' ); // будет "41", а не "221"
```
***Сложение и преобразование строк*** — это особенность бинарного плюса +. *Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.*

```js
alert( 6 - '2' ); // 4, '2' приводится к числу
alert( '6' / '2' ); // 3, оба операнда приводятся к числам
```

## Приведение к числу, унарный +
Плюс + существует в двух формах: бинарной, которую мы использовали выше, и унарной.

Унарный, то есть применённый к одному значению, плюс + ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число.

```js
// Не влияет на числа
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// Преобразует не числа в числа
alert( +true ); // 1
alert( +"" );   // 0
```
На самом деле это то же самое, что и Number(...), только короче.

Необходимость преобразовывать строки в числа возникает очень часто. Например, обычно значения полей HTML-формы — это строки. А что, если их нужно, к примеру, сложить?

Бинарный плюс сложит их как строки, а если воспользоваться преобразованием, получится короткая и явная запись:
```js 
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", так как бинарный плюс объединяет строки
// оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5
```
## Приоритет операторов
В JavaScript много операторов. Каждый оператор имеет соответствующий номер приоритета. Тот, у кого это число больше, – выполнится раньше. Если приоритет одинаковый, то порядок выполнения – слева направо.

[Полная таблица приоритетов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)
Отрывок из таблицы об операторах упомянутых ваше:

| Приоритет | Название             | Обозначение |
| --------- | -------------------- | ----------- |
| …         | …                    | …           |
| 15        | унарный плюс         | `+`         |
| 15        | унарный минус        | `-`         |
| 14        | возведение в степень | `**`        |
| 13        | умножение            | `*`         |
| 13        | деление              | `/`         |
| 12        | сложение             | `+`         |
| 12        | вычитание            | `-`         |
| …         | …                    | …           |
| 2         | присваивание         | `=`         |
| …         | …                    | …           |
## Присваивание
У присваивания один из самых низких приоритетов: `2`.

Именно поэтому, когда переменной что-либо присваивают, например, `x = 2 * 2 + 1`, то сначала выполнится арифметика, а уже затем произойдёт присваивание `=` с сохранением результата в `x`.
```js
let x = 2 * 2 + 1;

alert( x ); // 5
```
### Присваивание = возвращает значение
Большинство операторов в JavaScript возвращают значение. Для некоторых это очевидно, например сложение `+` или умножение `*`. Но и оператор присваивания не является исключением.

Вызов `x = value` записывает `value` в `x` _и возвращает его_.

Благодаря этому присваивание можно использовать как часть более сложного выражения:
```js
let a = 1;
let b = 2;

let c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
```

***Однако писать самим в таком стиле не рекомендуется.*** Такие трюки не сделают ваш код более понятным или читабельным.
### Присваивание по цепочке

```js 
let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```
Опять-таки, чтобы код читался легче, лучше разделять подобные конструкции на несколько строчек:
```js 
c = 2 + 2;
b = c;
a = c;
```
Польза от такого стиля особенно ощущается при быстром просмотре кода.

### Сокращённая арифметика с присваиванием

Часто нужно применить оператор к переменной и сохранить результат в ней же.
```js 
let n = 2;
n = n + 5;
n = n * 2;
// сокращённый вариант кода
let n = 2;
n += 5; // теперь n = 7 (работает как n = n + 5)
n *= 2; // теперь n = 14 (работает как n = n * 2)

alert( n ); // 14
```

Подобные краткие формы записи существуют для **всех** арифметических и побитовых операторов: `/=`, `-=`, `**=` и так далее.

Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после большинства других операций:

```js
let n = 2;

n *= 3 + 5;

alert( n ); // 16  (сначала выполнится правая часть, выражение идентично n *= 8)
```

### Инкремент/декремент
Одной из наиболее частых числовых операций является увеличение или уменьшение на единицу.

Для этого существуют даже специальные операторы:
- Инкремент `++` увеличивает переменную на 1:
```js 
let counter = 2;
counter++;        // работает как counter = counter + 1, просто запись короче
alert( counter ); // 3
```
- Декремент `--` уменьшает переменную на 1:
```js 
let counter = 2;
counter--;        // работает как counter = counter - 1, просто запись короче
alert( counter ); // 1
```
> [!NOTE] Важно:
> Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведёт к ошибке.

Операторы ++ и -- бывают двух видов:
- **Префиксная форма**: `++counter`
- **Постфиксная форма**: `counter++`

Если результат оператора **не используется**, разницы между ними нет — переменная просто изменяется.

Разница появляется, когда важно **возвращаемое значение**:
- `++counter` — **сначала** изменяет значение, **потом возвращает новое**
- `counter++` — **сначала возвращает старое**, **потом изменяет**
```js
//Префиксная
let counter = 1;
let a = ++counter;
alert(a); // 2
//Постфиксная
let counter = 1;
let a = counter++;
alert(a); // 1
```
> [!NOTE] Инкремент/декремент можно использовать в любых выражениях
> Операторы `++/--` могут также использоваться внутри выражений. Их приоритет выше, чем у большинства других арифметических операций.
> ``` js 
> let counter = 1;
> alert( 2 * ++counter ); // 4
> ```
> Сравните с:
> ```js
> let counter = 1;
alert( 2 * counter++ ); // 2, потому что counter++ возвращает "старое" значение
> ```
> Хотя технически здесь всё в порядке, такая запись обычно ***делает код менее читабельным***. Одна строка выполняет множество действий – нехорошо.
> 
> ***Лучше использовать стиль «одна строка – одно действие»***.
## Побитовые операторы
Побитовые операторы работают с 32-разрядными целыми числами (при необходимости приводят к ним), на уровне их внутреннего двоичного представления.

Эти операторы не являются чем-то специфичным для JavaScript, они поддерживаются в большинстве языков программирования.

Поддерживаются следующие побитовые операторы:
- AND(и) ( `&` )
- OR(или) ( `|` )
- XOR(побитовое исключающее или) ( `^` )
- NOT(не) ( `~` )
- LEFT SHIFT(левый сдвиг) ( `<<` )
- RIGHT SHIFT(правый сдвиг) ( `>>` )
- ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( `>>>` )

## Оператор «запятая»
Оператор «запятая» предоставляет нам возможность вычислять несколько выражений, разделяя их запятой `,`. Каждое выражение выполняется, но возвращается результат только последнего.
```js
let a = (1 + 2, 3 + 4);

alert( a ); // 7 (результат вычисления 3 + 4)
```
Первое выражение `1 + 2` выполняется, а результат отбрасывается. Затем идёт `3 + 4`, выражение выполняется и возвращается результат.


> [!NOTE] Запятая имеет очень низкий **приоритет**
> Пожалуйста, обратите внимание, что оператор , имеет очень низкий приоритет, ниже =, поэтому скобки важны в приведённом выше примере.
> Попробуйте запустить следующий код (строгий режим "use strict" в примере ниже не используется, иначе мы бы получили ошибку):
> ```js
> a = 1 + 2, 3 + 4;
> alert(a); // 3
> ```
> Без скобок в a = 1 + 2, 3 + 4 сначала выполнится +, суммируя числа в a = 3, 7, затем оператор присваивания = присвоит a = 3, а то, что идёт дальше, будет проигнорировано. Всё так же, как в (a = 1 + 2), 3 + 4.

# Операторы сравнения 
Многие операторы сравнения известны нам из математики.
- Больше/меньше: `a > b`, `a < b`.
- Больше/меньше или равно: `a >= b`, `a <= b`.
- Равно: `a == b`. Обратите внимание, для сравнения используется двойной знак равенства `==`. Один знак равенства `a = b` означал бы присваивание.
- Не равно. В математике обозначается символом `≠`, но в JavaScript записывается как `a != b`.
## Результат сравнения имеет логический тип
```js
alert( 2 > 1 );  // true (верно)
alert( 2 == 1 ); // false (неверно)
alert( 2 != 1 ); // true (верно)
```
Результат сравнения можно присвоить переменной, как и любое значение:
```js
let result = 5 > 4; // результат сравнения присваивается переменной result
alert( result ); // true
```

## Сравнение строк
Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок.

```js
alert( 'Я' > 'А' ); // true
alert( 'Коты' > 'Кода' ); // true
alert( 'Сонный' > 'Сон' ); // true
```

Алгоритм сравнения двух строк довольно прост:
1. Сначала сравниваются первые символы строк.
2. Если первый символ первой строки больше *(меньше),* чем первый символ второй, то первая строка больше *(меньше)* второй. Сравнение завершено.
3. Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.
4. Сравнение продолжается, пока не закончится одна из строк.
5. Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.
> [!NOTE] Используется кодировка Unicode, а не настоящий алфавит
> Приведённый выше алгоритм сравнения похож на алгоритм, используемый в словарях и телефонных книгах, но между ними есть и различия.
> 
> Например, в JavaScript имеет значение регистр символов. Заглавная буква "A" не равна строчной "a". Какая же из них больше? Строчная "a". Почему? Потому что строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript (Unicode). 

## Сравнение разных типов
При сравнении значений разных типов JavaScript приводит каждое из них к числу.
```js
alert( '2' > 1 ); // true, строка '2' становится числом 2
alert( '01' == 1 ); // true, строка '01' становится числом 1
```
> [!NOTE] Забавное следствие
> Возможна следующая ситуация:
> - Два значения равны.
> - Одно из них true как логическое значение, другое – false.
> ```js
> let a = 0;
> alert( Boolean(a) ); // false
> let b = "0";
> alert( Boolean(b) ); // true
> alert(a == b); // true!```

## Строгое сравнение
Использование обычного сравнения `==` может вызывать проблемы. Например, оно не отличает `0` от `false`:
```js
alert( '' == false ); // true
alert( 0 == false ); // true
```
Это происходит из-за того, что операнды разных типов преобразуются оператором `==` к числу. В итоге, и пустая строка, и `false` становятся нулём.

***Оператор строгого равенства `===` проверяет равенство без приведения типов.***

Другими словами, если `a` и `b` имеют разные типы, то проверка `a === b` немедленно возвращает `false` без попытки их преобразования.
```js
alert( 0 === false ); // false, так как сравниваются разные типы
```
Ещё есть оператор строгого неравенства `!==`, аналогичный `!=`.

## Сравнение с null и undefined
Поведение `null` и `undefined` при сравнении с другими значениями — особое:
### При строгом равенстве `===`
Эти значения различны, так как различны их типы.
```js
alert( null === undefined ); // false
```
### При нестрогом равенстве ==
Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.
```js
alert( null == undefined ); // true
```

**При использовании математических операторов и других операторов сравнения `< > <= >= Значения `null/undefined` преобразуются к числам: `null` становится `0`, а `undefined` – `NaN`.`**
### Странный результат сравнения null и 0
```js
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```
Причина в том, что нестрогое равенство и сравнения `> < >= <=` работают по-разному. Сравнения преобразуют `null` в число, рассматривая его как `0`. Поэтому выражение (3) `null >= 0` истинно, а `null > 0` ложно.
### Несравненное значение undefined
Значение `undefined` несравнимо с другими значениями:
```js
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```
- Сравнения `(1)` и `(2)` возвращают `false`, потому что `undefined` преобразуется в `NaN`, а `NaN` – это специальное числовое значение, которое возвращает `false` при любых сравнениях.
- Нестрогое равенство `(3)` возвращает `false`, потому что `undefined` равно только `null`, `undefined` и ничему больше.
## Как избежать проблем
- Относитесь очень осторожно к любому сравнению с `undefined/null`, кроме случаев строгого равенства `===`.
- Не используйте сравнения `>= > < <=` с переменными, которые могут принимать значения `null/undefined`, разве что вы полностью уверены в том, что делаете. Если переменная может принимать эти значения, то добавьте для них отдельные проверки.
# Логические операторы
В JavaScript есть семь логических операторов:
- `||` (ИЛИ)
    - `||=` (Оператор логического присваивания ИЛИ)
- `&&` (И)
    - `&&=` (Оператор логического присваивания И)
- `!` (НЕ)
- `??` (Оператор нулевого слияния)
    - `??=` (Оператор нулевого присваивания)

*Несмотря на своё название, данные операторы могут применяться к значениям любых типов. Полученные результаты также могут иметь различный тип.*
## || (ИЛИ)

Оператор «ИЛИ» выглядит как двойной символ вертикальной черты:
```js
result = a || b;
```
В случае, если какой-либо из аргументов `true`, он вернёт `true`, в противоположной ситуации возвращается `false`. *В JavaScript, как мы увидим далее, этот оператор работает несколько иным образом.*
```js
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

*Если значение не логического типа, то оно к нему приводится в целях вычислений.*
Например, число `1` будет воспринято как `true`, а `0` – как `false`

Можно сделать цепочку ИЛИ:
```js
let hour = 12;
let isWeekend = true;

result = hour < 10 || hour > 18 || isWeekend;
```
### ИЛИ "||" находит первое истинное значение
Описанная выше логика соответствует традиционной. Теперь давайте поработаем с «дополнительными» возможностями JavaScript.
```js
result = value1 || value2 || value3;
```
Оператор `||` выполняет следующие действия:
- Вычисляет операнды слева направо.
- Каждый операнд конвертирует в логическое значение. Если результат `true`, останавливается и возвращает ***исходное значение этого операнд***а.
- Если все операнды являются ложными (`false`), возвращает последний из них.

Другими словами, цепочка ИЛИ `||` возвращает первое истинное значение или последнее, если такое значение не найдено.
```js
alert( 1 || 0 ); // 1 (1 - истинное значение)
alert( true || 'какая-то строка' ); // true

alert( null || 1 ); // 1 (первое истинное значение)
alert( null || 0 || 1 ); // 1 (первое истинное значение)
alert( undefined || null || 0 ); // 0 (поскольку все ложно, возвращается последнее значение)
```
Это делает возможным более интересное применение оператора по сравнению с «чистым, традиционным, только булевым ИЛИ».

#### Получение первого истинного значения из списка переменных или выражений.
Например, у нас есть переменные `firstName`, `lastName` и `nickName`, все они необязательные (т.е. они могут быть неопределенными или иметь ложные значения).

Воспользуемся оператором ИЛИ `||`, чтобы выбрать ту переменную, в которой есть данные, и показать её (или «Аноним», если ни в одной переменной данных нет):
```js
let firstName = "";
let lastName = "";
let nickName = "Суперкодер";

alert( firstName || lastName || nickName || "Аноним"); // Суперкодер
```
Если бы все переменные были ложными, в качестве результата мы бы наблюдали `"Аноним"`.
#### Сокращённое вычисление.
Это означает, что ИЛИ `||` обрабатывает свои операнды до тех пор, пока не будет достигнуто первое истинностное значение, и затем это значение сразу же возвращается, даже не затрагивая другие операнды.

Важность этой особенности становится очевидной, если операнд – это не просто значение, а выражение с сопутствующим эффектом, как, например, присваивание переменной или вызов функции.

В приведенном ниже примере срабатывает только второй `alert`:
```js
true || alert("никогда не сработает");
false || alert("сработает");
```
## ||= (Логическое присваивание ИЛИ)

> [!NOTE] Новая возможность
> Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться [[полифил]].

Результат выполнения данного оператора напрямую зависит от действий уже известного нам `||`. `a ||= b;`

Оператор `||=` принимает два операнда и выполняет следующие действия:
- Вычисляет операнды слева направо.
- Конвертирует `a` в логическое значение.
- Если `a` ложно, присваивает `a` значение `b`.

Перепишем `a ||= b` под вид «сокращённого вычисления»:
```js
a || (a = b);
```
Мы уже знаем, что ИЛИ `||` возвращает _первое истинное значение_, поэтому, если `a` является таковым, вычисление до правой части выражения не дойдёт.

```js
let johnHasCar = false;

johnHasCar ||= "У Джона нет машины!"; // то же самое, что false || (johnHasCar = "...")

alert( johnHasCar ); // "У Джона нет машины!"
```
…А здесь происходит преобразование к логическому значению:
```js
let manufacturer = ""; // оператор ||= преобразует пустую строку "" к логическому значению false

manufacturer ||= "Неизвестный производитель"; // то же самое, что false || (manufacturer = "...")

alert( manufacturer ); // "Неизвестный производитель"
```
Оператор логического присваивания ИЛИ `||=` – это «[синтаксический сахар](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%81%D0%B0%D1%85%D0%B0%D1%80)», добавленный в язык в качестве более короткого варианта записи `if`-выражений с присваиванием.
## && (И)
``` js
result = a && b;
```
В традиционном программировании И возвращает `true`, если оба аргумента истинны, а иначе – `false`:
```js 
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```
### И «&&» находит первое ложное значение
При нескольких подряд операторах И:
```javascript
result = value1 && value2 && value3;
```
Оператор `&&` выполняет следующие действия:
- Вычисляет операнды слева направо.
- Каждый операнд преобразует в логическое значение. Если результат `false`, останавливается и возвращает исходное значение этого операнда.
- Если все операнды были истинными, возвращается последний.

Другими словами, И возвращает первое ложное значение. Или последнее, если ложное не найдено.

***Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое ложное значение, а ИЛИ –  первое истинное.***

Можно передать несколько значений подряд. В таком случае возвратится первое «ложное» значение, на котором остановились вычисления.
```js
alert( 1 && 2 && null && 3 ); // null
```
Когда все значения верны, возвращается последнее
```js
alert( 1 && 2 && 3 ); // 3
```
> [!NOTE] Приоритет оператора `&&` больше, чем у `||`
> Приоритет оператора И `&&` больше, чем ИЛИ `||`, так что он выполняется раньше. 
> 
> Таким образом, код `a && b || c && d` по существу такой же, как если бы выражения `&&` были в круглых скобках: `(a && b) || (c && d)`.

> [!NOTE] Не заменяйте `if` на `||` или `&&`
> Иногда люди используют оператор И `&&` как «более короткий способ записи `if`-выражения».
> Например: 
> ```javascript
> let x = 1;
> (x > 0) && alert( 'x больше нуля!' );
> ```
> Инструкция в правой части `&&` будет выполнена только в том случае, если вычисление дойдет до нее. То есть, только если `(x > 0)` истинно.
> 
> Таким образом, мы имеем аналог для следующего кода:
> ```js
> let x = 1;
> if (x > 0) alert( 'x больше нуля!' );
> ```
> Несмотря на то, что вариант с `&&` кажется более коротким, `if` более нагляден и, как правило, более читабелен. Поэтому мы рекомендуем использовать каждую конструкцию по назначению: использовать `if`, если нам нужно `if`, и использовать `&&`, если нам нужно И.
## &&= (Логическое присваивание И)
Оператор логического присваивания И `&&=` записывается как два амперсанда `&&` и символ присваивания `=`.
> [!NOTE] Новая возможность
> Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться [[полифил]].

Принцип действия `&&=` практически такой же, как и у оператора логического присваивания ИЛИ `||=`. Единственное отличие заключается в том, что `&&=` присвоит `a` значение `b` только в том случае, если `a` _истинно_.

Концепция оператора логического присваивания И `&&=` также основывается на «сокращённом вычислении»:
```js
a && (a = b);
```
Пример использования:
```js
let greeting = "Привет"; // строка непустая, поэтому будет преобразована к логическому значению true оператором &&=

greeting &&= greeting + ", пользователь!"; // то же самое, что true && (greeting = greeting + "...")

alert( greeting ) // "Привет, пользователь!"
```
Так как оператор логического присваивания И `&&=` также как и `||=` является «синтаксическим сахаром», мы можем без проблем переписать пример выше с использованием привычного для нас `if`. 

## ! (НЕ)
Оператор НЕ представлен восклицательным знаком `!`.

Синтаксис довольно прост:

```javascript
result = !value;
```

Оператор принимает один аргумент и выполняет следующие действия:
1. Сначала приводит аргумент к логическому типу `true/false`.
2. Затем возвращает противоположное значение.

***В частности, двойное НЕ `!!` используют для преобразования значений к логическому типу***
```js 
alert( !!"непустая строка" ); // true
alert( !!null ); // false
```
# Операторы нулевого слияния и присваивания: '??', '??='
> [!NOTE] Новая возможность
> Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться [полифил](https://learn.javascript.ru/polyfills).
## Оператор нулевого слияния (??)

^cb6813

 Для краткости будем говорить, что значение «определено», если оно не равняется ни `null`, ни `undefined`.
 Результат выражения `a ?? b` будет следующим:
- если `a` определено, то `a`,
- если `a` не определено, то `b`.
Оператор нулевого слияния не является чем-то принципиально новым. Это всего лишь удобный синтаксис, как из двух значений получить одно, которое «определено».

Вот как можно переписать выражение `result = a ?? b`, используя уже знакомые нам операторы:
```js
result = (a !== null && a !== undefined) ? a : b;
```

**Как правило, оператор `??` нужен для того, чтобы задать значение по умолчанию для потенциально неопределённой переменной.**

Например, здесь мы отобразим `user`, если её значение не `null/undefined`, в противном случае `Аноним`:
```js
let user;

alert(user ?? "Аноним"); // Аноним (user не существует)
```

Мы хотели бы отобразить имя пользователя, используя одну из этих переменных, или показать «Аноним», если все они `null/undefined`.

Для этого воспользуемся оператором `??`:
```js
let firstName = null;
let lastName = null;
let nickName = "Суперкодер";

// показывает первое значение, которое определено:
alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер
```
### Сравнение с ||

Оператор ИЛИ `||` можно использовать для того же, что и `??`.

Если в приведённом выше коде заменить `??` на `||`, то будет тот же самый результат:
```js
let firstName = null;
let lastName = null;
let nickName = "Суперкодер";

// показывает первое истинное значение:
alert(firstName || lastName || nickName || "Аноним"); // Суперкодер
```
Важное различие между ними заключается в том, что:
- `||` возвращает первое **_истинное_** значение.
- `??` возвращает первое **_определённое_** значение.

Проще говоря, оператор `||` не различает `false`, `0`, пустую строку `""` и `null/undefined`. Для него они все одинаковы, т.е. являются ложными значениями. Если первым аргументом для оператора `||` будет любое из перечисленных значений, то в качестве результата мы получим второй аргумент.

Однако на практике часто требуется использовать значение по умолчанию только тогда, когда переменная является `null/undefined`. Ведь именно тогда значение действительно неизвестно/не определено.

Наглядный пример:
```js
let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
```
### Приоритет
Приоритет оператора `??` такой же, как и у `||`. Они оба равны `3` в [таблице на MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table).

Это означает, что, как и `||`, оператор нулевого слияния `??` вычисляется до `=` и `?`, но после большинства других операций, таких как `+`, `*`.
Так что, в выражениях такого вида понадобятся скобки:
```js
let height = null;
let width = null;

// важно: используйте круглые скобки
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000

```
Иначе, если опустить скобки, оператор `*` выполнится первым, так как у него приоритет выше, чем у `??`, и это приведёт к неправильным результатам.
```js
// без скобок
let area = height ?? 100 * width ?? 50;

// ...сработает вот так (совсем не как нам нужно):
let area = height ?? (100 * width) ?? 50;
```
### Использование ?? вместе с && или ||
По соображениям безопасности JavaScript запрещает использование оператора `??` вместе с `&&` и `||`, если приоритет явно не указан при помощи круглых скобок.

Выполнение следующего кода приведёт к ***синтаксической ошибке***:
```js
let x = 1 && 2 ?? 3; // Синтаксическая ошибка
```

Это, безусловно, спорное ограничение было добавлено в спецификацию языка с целью избежать программные ошибки, когда люди начнут переходить с `||` на `??`.

Используйте скобки, чтобы обойти это ограничение:
```js
let x = (1 && 2) ?? 3; // Работает без ошибок

alert(x); // 2
```
## Оператор нулевого присваивания (??=)
Предположим, нам необходимо проверить, равна ли переменная `null` или `undefined`, и если это так — присвоить этой переменной какое-либо другое значение.
```js
let userAge = null;

if (userAge === null || userAge === undefined) {
  userAge = 18;
}
```
Существует оператор, более подходящий для подобных задач. Вот его синтаксис:
```js
x ??= y
```
Оператор `??=` присвоит `x` значение `y` только в том случае, если `x` _не определено_ (`null`/`undefined`).

```js
let userAge = null;

userAge ??= 18;

alert(userAge) // 18
```
> [!NOTE] Обратите внимание
> если бы `userAge` не был равен `null`/`undefined`, то выражение справа от `??=` никогда бы не выполнилось:
> ```js
> let userAge = 18;
> userAge ??= alert("не сработает");
> userAge ??= 21;
> userAge ??= null;
> alert(userAge) // по-прежнему 18
> ```
