# Функции 
Примеры встроенных функций – это `alert(message)`, `prompt(message, default)` и `confirm(question)`.
## Объявление функции
Вначале идёт ключевое слово `function`, после него _имя функции_, затем список _параметров_ в круглых скобках через запятую (в вышеприведённом примере он пустой) и, наконец, код функции, также называемый «телом функции», внутри фигурных скобок.
```js
function имя(параметры) {
  ...тело...
}
```
Наша новая функция может быть вызвана по своему имени: `showMessage()`.

Например:
```javascript
function showMessage() {
  alert( 'Всем привет!' );
}

showMessage();
showMessage();
```
## Локальные и внешние переменные
Переменные, объявленные внутри функции, видны только внутри этой функции.
Например:
```js
function showMessage() {
  let message = "Привет, я JavaScript!"; // локальная переменная

  alert( message );
}

showMessage(); // Привет, я JavaScript!

alert( message ); // <-- будет ошибка, т.к. переменная видна только внутри функции
```
У функции есть доступ к внешним переменным, например:
```js
let userName = 'Вася';

function showMessage() {
  let message = 'Привет, ' + userName;
  alert(message);
}

showMessage(); // Привет, Вася
```
Функция обладает полным доступом к внешним переменным и может изменять их значение.
```js
let userName = 'Вася';

function showMessage() {
  userName = "Петя"; // (1) изменяем значение внешней переменной

  let message = 'Привет, ' + userName;
  alert(message);
}

alert( userName ); // Вася перед вызовом функции

showMessage();

alert( userName ); // Петя, значение внешней переменной было изменено функцией
```

***Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю.*** 
Например, в коде ниже функция использует локальную переменную `userName`. Внешняя будет проигнорирована:
```js
let userName = 'Вася';

function showMessage() {
  let userName = "Петя"; // объявляем локальную переменную

  let message = 'Привет, ' + userName; // Петя
  alert(message);
}

// функция создаст и будет использовать свою собственную локальную переменную userName
showMessage();

alert( userName ); // Вася, не изменилась, функция не трогала внешнюю переменную
```
> [!NOTE] Глобальные переменные
> Переменные, объявленные снаружи всех функций, такие как внешняя переменная `userName` в вышеприведённом коде – называются _глобальными_.
> 
> _Глобальные переменные_ видимы для любой функции (если только их не перекрывают одноимённые локальные переменные).
> 
> Желательно сводить использование глобальных переменных к минимуму. В современном коде обычно мало или совсем нет глобальных переменных. Хотя они иногда полезны для хранения важнейших «общепроектовых» данных.
## Параметры
Мы можем передать внутрь функции любую информацию, используя параметры.
```js
function showMessage(from, text) { // параметры: from, text
  alert(from + ': ' + text);
}

showMessage('Аня', 'Привет!'); // Аня: Привет! (*)
showMessage('Аня', "Как дела?"); // Аня: Как дела? (**)
```
Когда функция вызывается в строках `(*)` и `(**)`, переданные значения копируются в локальные переменные `from` и `text`. Затем они используются в теле функции.

Вот ещё один пример: у нас есть переменная `from`, и мы передаём её функции.
> Функция изменяет значение `from`, но это изменение не видно снаружи. Функция всегда получает только копию значения:
```js
function showMessage(from, text) {

  from = '*' + from + '*'; // немного украсим "from"

  alert( from + ': ' + text );
}

let from = "Аня";

showMessage(from, "Привет"); // *Аня*: Привет

// значение "from" осталось прежним, функция изменила значение локальной переменной
alert( from ); // Аня
```
Значение, передаваемое в качестве параметра функции, также называется _аргументом_.

Другими словами:
- Параметр – это переменная, указанная в круглых скобках в объявлении функции.
- Аргумент – это значение, которое передаётся функции при её вызове.

Рассматривая приведённый выше пример, мы могли бы сказать: «функция `showMessage` объявляется с двумя параметрами, затем вызывается с двумя аргументами: `from` и `"Привет"`».

## Значения по умолчанию
Если при вызове функции аргумент не был указан, то его значением становится `undefined`.=

Например, вышеупомянутая функция `showMessage(from, text)` может быть вызвана с одним аргументом:
```javascript
showMessage("Аня");
```
Это не приведёт к ошибке. Такой вызов выведет `"*Аня*: undefined"`. В вызове не указан параметр `text`, поэтому предполагается, что `text === undefined`.

Если мы хотим задать параметру `text` значение по умолчанию, мы должны указать его после `=`:
```js
function showMessage(from, text = "текст не добавлен") {
  alert( from + ": " + text );
}

showMessage("Аня"); // Аня: текст не добавлен
```

В данном случае `"текст не добавлен"` это строка, но на её месте могло бы быть и более сложное выражение, которое бы вычислялось и присваивалось при отсутствии параметра. Например:
```js
function showMessage(from, text = anotherFunction()) {
  // anotherFunction() выполнится только если не передан text
  // результатом будет значение text
}
```

> [!NOTE] Вычисление параметров по умолчанию
> В JavaScript параметры по умолчанию вычисляются каждый раз, когда функция вызывается без соответствующего аргумента.
> 
> В приведённом выше примере, функция `anotherFunction()` не будет вызвана вообще, если указан аргумент `text`.
> 
> С другой стороны, функция будет независимо вызываться каждый раз, когда аргумент `text` отсутствует.

> [!NOTE] Использование параметров по умолчанию в ранних версиях JavaScript
> Ранние версии JavaScript не поддерживали параметры по умолчанию. Поэтому существуют альтернативные способы, которые могут встречаться в старых скриптах.
> 
> Например, явная проверка на `undefined`:
> ```js
> function showMessage(from, text) {
> 	if (text === undefined) {
> 		text = 'текст не добавлен';  
> 	}
> 	alert( from + ": " + text );
> }
> ```
> …Или с помощью оператора `||`:
> ```js
> function showMessage(from, text) {
> 	 // Если значение text ложно, тогда присвоить параметру text значение по умолчанию
> 	 // заметим, что при этом пустая строка text === "" будет также считаться отсутствующим значением
> 	 text = text || 'текст не добавлен';
> 	 ...
> }
> ```

## Альтернативные параметры по умолчанию
Иногда имеет смысл присваивать значения по умолчанию для параметров не в объявлении функции, а на более позднем этапе.

Во время выполнения функции мы можем проверить, передан ли параметр, сравнив его с `undefined`:
```js
function showMessage(text) {
  // ...
  if (text === undefined) { // если параметр отсутствует
    text = 'пустое сообщение';
  }
  alert(text);
}
showMessage(); // пустое сообщение
```
…Или мы можем использовать оператор `||`:
```js
function showMessage(text) {
  // если значение text ложно или равняется undefined, тогда присвоить text значение 'пусто'
  text = text || 'пусто';
  ...
}
```
Современные движки JavaScript поддерживают ***оператор нулевого слияния*** [[Операторы#^cb6813]] `??`. Его использование будет лучшей практикой, в случае, если большинство ложных значений, таких как `0`, следует расценивать как «нормальные».
```js
function showCount(count) {
  // если count равен undefined или null, показать "неизвестно"
  alert(count ?? "неизвестно");
}
showCount(0); // 0
showCount(null); // неизвестно
showCount(); // неизвестно
```
## Возврат значения
Функция может вернуть результат, который будет передан в вызвавший её код.
```js
function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert( result ); // 3
```
Директива `return` может находиться в любом месте тела функции. Как только выполнение доходит до этого места, функция останавливается, и значение возвращается в вызвавший её код (присваивается переменной `result` выше).

Возможно использовать `return` и без значения. Это приведёт к немедленному выходу из функции.
Например:
```js
function showMovie(age) {
  if ( !checkAge(age) ) {
    return;
  }

  alert( "Вам показывается кино" ); // (*)
  // ...
}
```
В коде выше, если `checkAge(age)` вернёт `false`, `showMovie` не выполнит `alert`.

> [!NOTE] Результат функции с пустым `return` или без него – `undefined`
> Если функция не возвращает значения, это всё равно, как если бы она возвращала `undefined`:
> ```js
> function doNothing() { /* пусто */ }
> alert( doNothing() === undefined ); // true
> ```
> Пустой `return` аналогичен `return undefined`:
> ```js
> function doNothing() {
> 	return;
> }
> alert( doNothing() === undefined ); // true
> ```


> [!NOTE] Никогда не добавляйте перевод строки между `return` и его значением
> Для длинного выражения в `return` может быть заманчиво разместить его на нескольких отдельных строках, например так:
> ```js
> return
>  (some + long + expression + or + whatever * f(a) + f(b))
> ```
> Таким образом, это фактически стало пустым `return`.
> 
> Если мы хотим, чтобы возвращаемое выражение занимало несколько строк, нужно начать его на той же строке, что и `return`. Или, хотя бы, поставить там открывающую скобку, вот так:
> ```js
> return (
>   some + long + expression
>   + or +
>   whatever * f(a) + f(b)
>   )
> ```
# Выбор имени функции
Функция – это действие. Поэтому имя функции обычно является глаголом. Оно должно быть кратким, точным и описывать действие функции, чтобы программист, который будет читать код, получил верное представление о том, что делает функция.

Как правило, используются глагольные префиксы, обозначающие общий характер действия, после которых следует уточнение. Обычно в командах разработчиков действуют соглашения, касающиеся значений этих префиксов.

Функции, начинающиеся с…

- `"get…"` – возвращают значение,
- `"calc…"` – что-то вычисляют,
- `"create…"` – что-то создают,
- `"check…"` – что-то проверяют и возвращают логическое значение, и т.д.

Примеры таких имён:
```js
showMessage(..)     // показывает сообщение
getAge(..)          // возвращает возраст (получая его каким-то образом)
calcSum(..)         // вычисляет сумму и возвращает результат
createForm(..)      // создаёт форму (и обычно возвращает её)
checkPermission(..) // проверяет доступ, возвращая true/false
```
> [!NOTE] Одна функция – одно действие
> Функция должна делать только то, что явно подразумевается её названием. И это должно быть одним действием.
> 
> Два независимых действия обычно подразумевают две функции, даже если предполагается, что они будут вызываться вместе (в этом случае мы можем создать третью функцию, которая будет их вызывать).
> 
> Несколько примеров, которые нарушают это правило:
> - `getAge` – будет плохим выбором, если функция будет выводить `alert` с возрастом (должна только возвращать его).
> - `createForm` – будет плохим выбором, если функция будет изменять документ, добавляя форму в него (должна только создавать форму и возвращать её).
> - `checkPermission` – будет плохим выбором, если функция будет отображать сообщение с текстом `доступ разрешён/запрещён` (должна только выполнять проверку и возвращать её результат).

> [!NOTE] Сверхкороткие имена функций
> Имена функций, которые используются _очень часто_, иногда делают сверхкороткими.
> 
> Например, фреймворк [jQuery](https://jquery.com/) определяет функцию с помощью `$`. В библиотеке [Lodash](https://lodash.com/) основная функция представлена именем `_`.
> 
> Это исключения. В основном имена функций должны быть в меру краткими и описательными.
# Функции и самодокументируемый код

Функции должны быть короткими и делать только что-то одно. Если это что-то большое, имеет смысл разбить функцию на несколько меньших. Иногда следовать этому правилу непросто, но это определённо хорошее правило.

Небольшие функции не только облегчают тестирование и отладку – само существование таких функций выполняет роль хороших комментариев!

Например, сравним ниже две функции `showPrimes(n)`. Каждая из них выводит простое число до `n`.
Первый вариант использует метку `nextPrime`:
```javascript
function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // простое
  }
}
```
Второй вариант использует дополнительную функцию `isPrime(n)` для проверки на простое:
```javascript
function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);  // простое
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
```
Второй вариант легче для понимания, не правда ли? Вместо куска кода мы видим название действия (`isPrime`). Иногда разработчики называют такой код _самодокументируемым_.

Таким образом, допустимо создавать функции, даже если мы не планируем повторно использовать их. Такие функции структурируют код и делают его более понятным.
# Function Expression и функции как значения
Функция в JavaScript – это не магическая языковая структура, а особого типа значение.

Синтаксис, который мы использовали до этого, называется **_Function Declaration_ (Объявление Функции):**
```js
function sayHi() {
  alert( "Привет" );
}
```
Существует ещё один синтаксис создания функций, который называется **_Function Expression_ (Функциональное Выражение).**

Данный синтаксис позволяет нам создавать новую функцию в середине любого выражения.
Это выглядит следующим образом:
```javascript
let sayHi = function() {
  alert( "Привет" );
};
```
Здесь мы можем видеть переменную `sayHi`, получающую значение, новую функцию, созданную как `function() { alert("Привет"); }`.

Поскольку создание функции происходит в контексте выражения присваивания (с правой стороны от `=`), это _Function Expression_.

Здесь мы сразу присваиваем её переменной, так что смысл этих примеров кода один и тот же: «создать функцию и поместить её в переменную `sayHi`».
## Функция – это значение
Независимо от того, как создаётся функция – она является значением. В обоих приведённых выше примерах функция хранится в переменной `sayHi`.

Мы даже можем вывести это значение с помощью `alert`:
```js
function sayHi() {
  alert( "Привет" );
}

alert( sayHi ); // выведет код функции
```
Обратите внимание, что последняя строка не вызывает функцию, потому что после `sayHi` нет круглых скобок. **Существуют языки программирования, в которых любое упоминание имени функции приводит к её выполнению, но JavaScript к таким не относится.**

В JavaScript функция – это значение, поэтому мы можем обращаться с ней как со значением. Приведённый выше код показывает её строковое представление, которое является её исходным кодом.

Конечно, функция – это особое значение, в том смысле, что мы можем вызвать её как `sayHi()`.

Но всё же это значение. Поэтому мы можем работать с ней так же, как и с другими видами значений.
Мы можем скопировать функцию в другую переменную:
```js
function sayHi() {   // (1) создаём
  alert( "Привет" );
}

let func = sayHi;    // (2) копируем

func(); // Привет     // (3) вызываем копию (работает)!
sayHi(); // Привет    //     эта тоже все ещё работает (почему бы и нет)
```
1. Объявление Function Declaration `(1)` создаёт функцию и помещает её в переменную с именем `sayHi`.
2. В строке `(2)` мы скопировали её значение в переменную `func`. Обратите внимание (ещё раз): нет круглых скобок после `sayHi`. Если бы они были, то выражение `func = sayHi()` записало бы _результат вызова_ `sayHi()` в переменную `func`, а не саму _функцию_ `sayHi`.
3. Теперь функция может вызываться как `sayHi()`, так и `func()`.

Мы также могли бы использовать Function Expression для объявления `sayHi` в первой строке:
```js
let sayHi = function() { // (1) создаём
  alert( "Привет" );
};

let func = sayHi;
// ...
```

> [!NOTE] Зачем нужна точка с запятой в конце?
> У вас мог возникнуть вопрос: Почему в Function Expression ставится точка с запятой `;` на конце, а в Function Declaration нет:
> ```js
> function sayHi() {
>   // ...
> }
> let sayHi = function() {
>   // ...
> };
> ```
> Ответ прост: Function Expression создаётся здесь как `function(...) {...}` внутри выражения присваивания: `let sayHi = …;`. Точку с запятой `;` рекомендуется ставить в конце выражения, она не является частью синтаксиса функции.
> 
> Точка с запятой нужна там для более простого присваивания, такого как `let sayHi = 5;`, а также для присваивания функции.
## Функции-«колбэки»
Рассмотрим больше примеров передачи функции в виде значения и использования функциональных выражений.

Напишем функцию `ask(question, yes, no)` с тремя параметрами:
`question`
Текст вопроса

`yes`
Функция, которая будет вызываться, если ответ будет «Yes»

`no`
Функция, которая будет вызываться, если ответ будет «No»

Функция должна задать вопрос `question` и, в зависимости от того, как ответит пользователь, вызвать `yes()` или `no()`:
```js
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "Вы согласны." );
}

function showCancel() {
  alert( "Вы отменили выполнение." );
}

// использование: функции showOk, showCancel передаются в качестве аргументов ask
ask("Вы согласны?", showOk, showCancel);
```
На практике подобные функции очень полезны. Основное отличие «реальной» функции `ask` от примера выше будет в том, что она использует более сложные способы взаимодействия с пользователем, чем простой вызов `confirm`.

**Аргументы `showOk` и `showCancel` функции `ask` называются _функциями-колбэками_ или просто _колбэками_.**

*Ключевая идея в том, что мы передаём функцию и ожидаем, что она вызовется обратно (от англ. «call back» – обратный вызов) когда-нибудь позже, если это будет необходимо. В нашем случае, `showOk` становится колбэком для ответа «yes», а `showCancel` – для ответа «no».*

Мы можем переписать этот пример значительно короче, используя Function Expression:
```js
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);
```
Здесь функции объявляются прямо внутри вызова `ask(...)`. У них нет имён, поэтому они называются _анонимными_. Такие функции недоступны снаружи `ask` (потому что они не присвоены переменным), но это как раз то, что нам нужно.

Подобный код, появившийся в нашем скрипте выглядит очень естественно, в духе JavaScript.
> [!NOTE] Функция – это значение, представляющее «действие
> Обычные значения, такие как строки или числа представляют собой _данные_.
> 
> Функции, с другой стороны, можно воспринимать как _действия_.
> 
> Мы можем передавать их из переменной в переменную и запускать, когда захотим.
## Function Expression в сравнении с Function Declaration
- _Function Declaration_: функция объявляется отдельной конструкцией «function…» в основном потоке кода.
```javascript
// Function Declaration
function sum(a, b) {
  return a + b;
}
```
- _Function Expression_: функция, созданная внутри другого выражения или синтаксической конструкции. В данном случае функция создаётся в правой части «выражения присваивания» `=`:
```javascript
// Function Expression
let sum = function(a, b) {
  return a + b;
};
```
Более тонкое отличие состоит в том, _когда_ создаётся функция движком JavaScript.

- **Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.**
После того, как поток выполнения достигнет правой части выражения присваивания `let sum = function…` – с этого момента, функция считается созданной и может быть использована (присвоена переменной, вызвана и т.д. ).

- **Function Declaration может быть вызвана раньше, чем она объявлена.**
Другими словами, когда движок JavaScript _готовится_ выполнять скрипт или блок кода, прежде всего он ищет в нём Function Declaration и создаёт все такие функции. Можно считать этот процесс «стадией инициализации».

И только после того, как все объявления Function Declaration будут обработаны, продолжится выполнение.

Например, так будет работать:
```javascript
sayHi("Вася"); // Привет, Вася

function sayHi(name) {
  alert( `Привет, ${name}` );
}
```
Функция `sayHi` была создана, когда движок JavaScript подготавливал скрипт к выполнению, и такая функция видна повсюду в этом скрипте.

…Если бы это было Function Expression, то такой код вызвал бы ошибку:
```js
sayHi("Вася"); // ошибка!

let sayHi = function(name) {  // (*) магии больше нет
  alert( `Привет, ${name}` );
};
```

**Ещё одна важная особенность Function Declaration заключается в их блочной области видимости.**

**В строгом режиме, когда Function Declaration находится в блоке `{...}`, функция доступна везде внутри блока. Но не снаружи него.**

Для примера давайте представим, что нам нужно объявить функцию `welcome()` в зависимости от значения переменной `age`, которое мы получим во время выполнения кода. И затем запланируем использовать её когда-нибудь в будущем.

Если мы попробуем использовать Function Declaration, это не заработает так, как задумывалось:
```javascript
let age = prompt("Сколько Вам лет?", 18);

// в зависимости от условия объявляем функцию
if (age < 18) {

  function welcome() {
    alert("Привет!");
  }

} else {

  function welcome() {
    alert("Здравствуйте!");
  }

}

// ...не работает
welcome(); // Error: welcome is not defined
```
Это произошло, так как объявление Function Declaration видимо только внутри блока кода, в котором располагается.

Вот ещё один пример:
```javascript
let age = 16; // возьмём для примера 16

if (age < 18) {
  welcome();               // \   (выполнится)
                           //  |
  function welcome() {     //  |
    alert("Привет!");      //  |  Function Declaration доступно
  }                        //  |  во всём блоке кода, в котором объявлено
                           //  |
  welcome();               // /   (выполнится)

} else {

  function welcome() {
    alert("Здравствуйте!");
  }
}

// здесь фигурная скобка закрывается,
// поэтому Function Declaration, созданные внутри блока кода выше -- недоступны отсюда.

welcome(); // Ошибка: welcome is not defined
```
Верным подходом будет воспользоваться функцией, объявленной при помощи Function Expression, и присвоить значение `welcome` переменной, объявленной снаружи `if`, что обеспечит нам нужную видимость.

Такой код заработает, как ожидалось:
```javascript
let age = prompt("Сколько Вам лет?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Привет!");
  };

} else {

  welcome = function() {
    alert("Здравствуйте!");
  };

}

welcome(); // теперь всё в порядке
```

> [!NOTE] Когда использовать Function Declaration, а когда Function Expression?
> Как правило, если нам понадобилась функция, в первую очередь нужно рассматривать синтаксис Function Declaration, который мы использовали до этого. Он даёт нам больше свободы в том, как мы можем организовывать код. Функции, объявленные таким образом, можно вызывать до их объявления.
> 
> Также функции вида `function f(…) {…}` чуть более заметны в коде, чем `let f = function(…) {…}`. Function Declaration легче «ловятся глазами».
> 
> …Но если Function Declaration нам не подходит по какой-то причине, или нам нужно условное объявление (мы рассмотрели это в примере выше), то следует использовать Function Expression.
# Стрелочные функции
Существует ещё один очень простой и лаконичный синтаксис для создания функций, который часто лучше, чем Function Expression.

Он называется «функции-стрелки» или «стрелочные функции» (arrow functions), т.к. выглядит следующим образом:
```js
let func = (arg1, arg2, ...argN) => expression;
```

Это создаёт функцию `func`, которая принимает аргументы `arg1..argN`, затем вычисляет `expression` в правой части с их использованием и возвращает результат.
```js
let sum = (a, b) => a + b;

/* Эта стрелочная функция представляет собой более короткую форму:

let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3
```

- Если у нас только один аргумент, то круглые скобки вокруг параметров можно опустить, сделав запись ещё короче:   
```javascript
let double = n => n * 2;
// примерно то же, что и: let double = function(n) { return n * 2 }

alert( double(3) ); // 6
```
- Если аргументов нет, круглые скобки будут пустыми, но они должны присутствовать:
```javascript
let sayHi = () => alert("Hello!");

sayHi();
```

Стрелочные функции можно использовать так же, как и Function Expression.

Например, для динамического создания функции:
```javascript
let age = prompt("Сколько Вам лет?", 18);

let welcome = (age < 18) ?
  () => alert('Привет!') :
  () => alert("Здравствуйте!");

welcome();
```
## Многострочные стрелочные функции
Иногда нам нужна более сложная функция, с несколькими выражениями и инструкциями. Это также возможно, нужно лишь заключить их в фигурные скобки. При этом важное отличие – в том, что в таких скобках для возврата значения нужно использовать `return` (как в обычных функциях).

Вроде этого:
```javascript
let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
  let result = a + b;
  return result; // если мы используем фигурные скобки, то нам нужно явно указать "return"
};

alert( sum(1, 2) ); // 3
```

