При написании скриптов зачастую встаёт задача сделать однотипное действие много раз. Для многократного повторения одного участка кода предусмотрены _циклы_.
# Цикл «while»
```js
while (condition) {
  // код
  // также называемый "телом цикла"
}
```
Код из тела цикла выполняется, пока условие `condition` истинно.

Цикл ниже выводит `i`, пока `i < 3`:
```js
let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++;
}
```

**Одно выполнение тела цикла по-научному называется _итерация_.**

Если бы строка `i++` отсутствовала в примере выше, то цикл бы повторялся (в теории) вечно. На практике, конечно, браузер не позволит такому случиться, он предоставит пользователю возможность остановить «подвисший» скрипт, а JavaScript на стороне сервера придётся «убить» процесс.

**Любое выражение или переменная может быть условием цикла, а не только сравнение: условие `while` вычисляется и преобразуется в логическое значение.**

Например, `while (i)` – более краткий вариант `while (i != 0)`:
```js
let i = 3;
while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
  alert( i );
  i--;
}
```

> [!NOTE] Фигурные скобки не требуются для тела цикла из одной строки
> Если тело цикла состоит лишь из одной инструкции, мы можем опустить фигурные скобки `{…}`:
> ```js
> let i = 3;
> while (i) alert(i--);
> ```
# Цикл «do…while»
Проверку условия можно разместить под телом цикла, используя специальный синтаксис `do..while`:
``` js
do {
  // тело цикла
} while (condition);
```
Цикл сначала выполнит тело, а затем проверит условие `condition`, и пока его значение равно `true`, он будет выполняться снова и снова.
```js
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```
# Цикл «for»
```js
for (начало; условие; шаг) {
  // ... тело цикла ...
}
```

| начало  | `let i = 0` | Выполняется один раз при входе в цикл                                                             |
| ------- | ----------- | ------------------------------------------------------------------------------------------------- |
| условие | `i < 3`     | Проверяется _перед_ каждой итерацией цикла.  <br>Если оно вычислится в `false`, цикл остановится. |
| тело    | `alert(i)`  | Выполняется снова и снова, пока условие вычисляется в `true`.                                     |
| шаг     | `i++`       | Выполняется _после_ тела цикла на каждой итерации _перед_ проверкой условия.                      |
```js
for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
  alert(i);
}
```
В целом, алгоритм работы цикла выглядит следующим образом:

```none
Выполнить начало
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ ...
```

> [!NOTE] Встроенное объявление переменной
> В примере переменная счётчика `i` была объявлена прямо в цикле. Это так называемое «встроенное» объявление переменной. Такие переменные существуют только внутри цикла.
> ```js
> for (let i = 0; i < 3; i++) {
>   alert(i); // 0, 1, 2
>   }
>   alert(i); // ошибка, нет такой переменной
> ```
> Вместо объявления новой переменной мы можем использовать уже существующую:\
> ```js
> let i = 0;
> for (i = 0; i < 3; i++) { // используем существующую переменную
>  alert(i); // 0, 1, 2
>  }
>  alert(i); // 3, переменная доступна, т.к. была объявлена снаружи цикла
> ```
## Пропуск частей «for»
Любая часть `for` может быть пропущена.

Для примера, мы можем пропустить `начало` если нам ничего не нужно делать перед стартом цикла.
```js
let i = 0; // мы уже имеем объявленную i с присвоенным значением

for (; i < 3; i++) { // нет необходимости в "начале"
  alert( i ); // 0, 1, 2
}
```
Можно убрать и `шаг`:
```js
let i = 0;

for (; i < 3;) {
  alert( i++ );
}
```
Это сделает цикл аналогичным `while (i < 3)`.

А можно и вообще убрать всё, получив бесконечный цикл:
```js
for (;;) {
  // будет выполняться вечно
}
```
**При этом сами точки с запятой `;` обязательно должны присутствовать, иначе будет ошибка синтаксиса.**
# Прерывание цикла: «break»
Обычно цикл завершается при вычислении _условия_ в `false`, но мы можем выйти из цикла в любой момент с помощью специальной директивы break.
```js
let sum = 0;

while (true) {

  let value = +prompt("Введите число", '');

  if (!value) break; // (*)

  sum += value;

}
alert( 'Сумма: ' + sum );
```
Директива `break` в строке `(*)` полностью прекращает выполнение цикла и передаёт управление на строку за его телом, то есть на `alert`.
# Переход к следующей итерации: continue

^bcedab

При выполнении директивы `continue` цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно `true`).

Например, цикл ниже использует `continue`, чтобы выводить только нечётные значения:
```js
for (let i = 0; i < 10; i++) {

  // если true, пропустить оставшуюся часть тела цикла
  if (i % 2 == 0) continue;

  alert(i); // 1, затем 3, 5, 7, 9
}
```

> [!NOTE] Директива `continue` позволяет избегать вложенности
> Цикл, который обрабатывает только нечётные значения, мог бы выглядеть так:
> ```js
> for (let i = 0; i < 10; i++) {
>   if (i % 2) {
>   alert( i );
>   }
> }
> ```
> С технической точки зрения он полностью идентичен. Действительно, вместо `continue` можно просто завернуть действия в блок `if`.
> 
> Однако мы получили дополнительный уровень вложенности фигурных скобок. Если код внутри if более длинный, то это ухудшает читаемость, в отличие от варианта с continue.


> [!NOTE] Нельзя использовать `break/continue` справа от оператора „?“
> Обратите внимание, что эти синтаксические конструкции не являются выражениями и не могут быть использованы с тернарным оператором `?`. В частности, использование таких директив, как `break/continue`, вызовет ошибку.
> 
> Например, если мы возьмём этот код:
> ```js
> if (i > 5) {
>   alert(i);
> } else {
>   continue;
> ```
> …и перепишем его, используя вопросительный знак:
> ```js
> (i > 5) ? alert(i) : continue; // continue здесь приведёт к ошибке
> ```
> …то будет синтаксическая ошибка.
> Это ещё один повод не использовать оператор вопросительного знака `?` вместо `if`.
# Метки для break/continue
Бывает, нужно выйти одновременно из нескольких уровней цикла сразу.

Например, в коде ниже мы проходимся циклами по `i` и `j`, запрашивая с помощью `prompt` координаты `(i, j)` с `(0,0)` до `(2,2)`:
```js
for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Значение на координатах (${i},${j})`, '');

    // Что если мы захотим перейти к Готово (ниже) прямо отсюда?
  }
}

alert('Готово!');
```

Обычный `break` после `input` лишь прервёт внутренний цикл, но этого недостаточно. Достичь желаемого поведения можно с помощью меток.

**_Метка_ имеет вид идентификатора с двоеточием перед циклом:**
```js
labelName: for (...) {
  ...
}
```

Вызов `break <labelName>` в цикле ниже ищет ближайший внешний цикл с такой меткой и переходит в его конец.
```js
outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Значение на координатах (${i},${j})`, '');

    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) break outer; // (*)

    // сделать что-нибудь со значениями...
  }
}

alert('Готово!');
```

Можно размещать метку на отдельной строке:
```javascript
outer:
for (let i = 0; i < 3; i++) { ... }
```

Директива `continue` также может быть использована с меткой. В этом случае управление перейдёт на следующую итерацию цикла с меткой.


> [!NOTE] Метки не позволяют «прыгнуть» куда угодно
> Метки не дают возможности передавать управление в произвольное место кода.
> Например, нет возможности сделать следующее:
> ```js
> break label; // не прыгает к метке ниже
> label: for (...)
> ```
> Директива `break` должна находиться внутри блока кода. Технически, подойдет любой маркированный блок кода, например:
> ```js
> label: {
>   // ...
>   break label; // работает
>   // ...
>  }
> ```
> …Хотя в 99.9% случаев `break` используется внутри циклов, как мы видели в примерах выше.
> К слову, `continue` возможно только внутри цикла.
