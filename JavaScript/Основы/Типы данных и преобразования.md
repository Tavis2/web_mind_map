Значение в JavaScript всегда относится к данным определённого типа.

Переменная в JavaScript может содержать любые данные. В один момент там может быть строка, а в другой – число:
```js
// Не будет ошибкой
let message = "hello";
message = 123456;
```

## Число
```js
let n = 123;
n = 12.345;
```
_Числовой_ тип данных (`number`) представляет как целочисленные значения, так и числа с плавающей точкой.

Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: `Infinity`, `-Infinity` и `NaN`.

1. `Infinity` представляет собой математическую [бесконечность]∞. Это особое значение, которое больше любого числа.
Мы можем получить его в результате деления на ноль:
```js
alert( 1 / 0 ); // Infinity
```
Или задать его явно:
```js
alert( Infinity ); // Infinity
```

2. `NaN` означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:
```js
alert( "не число" / 2 ); // NaN, такое деление является ошибкой
```
Значение `NaN` «прилипчиво». Любая математическая операция с `NaN` возвращает `NaN`:
```js
alert( NaN + 1 ); // NaN
alert( 3 * NaN ); // NaN
alert( "не число" / 2 - 1 ); // NaN
```
**Если где-то в математическом выражении есть NaN, то оно распространяется на весь результат**. Но есть одно исключение: 
```js
alert(NaN ** 0) // результат будет равен 1 
```


> [!NOTE] Математические операции – безопасны
> Математические операции в JavaScript «безопасны». Мы можем делать что угодно: делить на ноль, обращаться с нечисловыми строками как с числами и т.д.
> 
> Cкрипт никогда не остановится с фатальной ошибкой (не «умрёт»). В худшем случае мы получим `NaN` как результат выполнения.
## BigInt
тип `number` _может_ хранить большие целые числа (до `1.7976931348623157 * 10^308`), но за пределами безопасного диапазона целых чисел `±(2^53-1)` будет ошибка точности, так как не все цифры помещаются в фиксированную 64-битную память. Поэтому можно хранить «приблизительное» значение.

**Безопасный диапазон чисел в JavaScript** — это диапазон **целых** чисел, которые тип `number` может хранить **без потери точности**.
```scss
-(2^53 - 1) … (2^53 - 1)
```
```js 
Number.MIN_SAFE_INTEGER // -9007199254740991
Number.MAX_SAFE_INTEGER //  9007199254740991
```

- безопасны **только целые числа** в этом диапазоне
- за пределами — JS перестаёт различать соседние целые
- дробные числа не бывают «безопасными» в принципе
- проверка: `Number.isSafeInteger(value)`

Например, эти два числа (прямо за пределами безопасного диапазона) совпадают:
```js
console.log(9007199254740991 + 1); // 9007199254740992
console.log(9007199254740991 + 2); // 9007199254740992
```

**То есть все нечетные целые числа, большие чем `(253-1)`, вообще не могут храниться в типе `number`.**

Тип `BigInt` был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.

Чтобы создать значение типа `BigInt`, необходимо добавить `n` в конец числового литерала:
```js
// символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n;
```

> [!NOTE] Поддержка
> В данный момент `BigInt` поддерживается только в браузерах Firefox, Chrome, Edge и Safari, но не поддерживается в IE.

## Строка
Строка (`string`) в JavaScript должна быть заключена в кавычки.
```js
let str = "Привет";
let str2 = 'Одинарные кавычки тоже подойдут';
let phrase = `Обратные кавычки позволяют встраивать переменные ${str}`;
```

В JavaScript существует три типа кавычек.

1. Двойные кавычки: `"Привет"`.
2. Одинарные кавычки: `'Привет'`.
3. Обратные кавычки: `` `Привет` ``.

Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript.

Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в `${…}`. Например:

```js 
let name = "Иван";

// Вставим переменную
alert( `Привет, ${name}!` ); // Привет, Иван!

// Вставим выражение
alert( `результат: ${1 + 2}` ); // результат: 3
```

> [!NOTE] Нет отдельного типа данных для одного символа.
> В некоторых языках, например C и Java, для хранения одного символа, например "a" или "%", существует отдельный тип. В языках C и Java это char.
> 
> В JavaScript подобного типа нет, есть только тип string. Строка может содержать ноль символов (быть пустой), один символ или множество.

## Булевый (логический) тип

Булевый тип (`boolean`) может принимать только два значения: `true` (истина) и `false` (ложь).
```js 
let nameFieldChecked = true; // да, поле отмечено
let ageFieldChecked = false; // нет, поле не отмечено

let isGreater = 4 > 1;
alert( isGreater ); // true (результатом сравнения будет "да")
```

## Значение «null»

Специальное значение `null` не относится ни к одному из типов, описанных выше.
Оно формирует отдельный тип, который содержит только значение `null`:
```js 
let age = null;
```
В JavaScript `null` не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках.

Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».

В приведённом выше коде указано, что значение переменной `age` неизвестно.

## Значение «undefined»

Специальное значение `undefined` также стоит особняком. Оно формирует тип из самого себя так же, как и `null`.

Оно означает, что «значение не было присвоено».

Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет `undefined`:
```js
let age;

alert(age); // выведет "undefined"
```

Технически мы можем присвоить значение `undefined` любой переменной:
```js
let age = 123;

// изменяем значение на undefined
age = undefined;

alert(age); // "undefined"
```
…**Но так делать не рекомендуетс**я. *Обычно `null` используется для присвоения переменной «пустого» или «неизвестного» значения, а `undefined` – для проверок, была ли переменная назначена.*

## Объекты и символы
Тип `object` (объект) – особенный.

Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.

## Оператор typeof
Оператор `typeof` возвращает тип аргумента. Это полезно, когда мы хотим обрабатывать значения различных типов по-разному или просто хотим сделать проверку.

У него есть две синтаксические формы:
```js 
// Обычный синтаксис
typeof 5 // Выведет "number"
// Синтаксис, напоминающий вызов функции (встречается реже)
typeof(5) // Также выведет "number"
```

Если передается выражение, то нужно заключать его в скобки, т.к. typeof имеет более высокий приоритет, чем бинарные операторы:
```js
typeof 50 + " Квартир"; // Выведет "number Квартир"
typeof (50 + " Квартир"); // Выведет "string"
```

Вызов `typeof x` возвращает строку с именем типа:

```js
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  

typeof null // "object"  

typeof alert // "function"  
```

> [!NOTE] Ошибка JavaScript
> Результатом вызова `typeof null` является `"object"`. Это официально признанная ошибка в `typeof`, ведущая начало с времён создания JavaScript и сохранённая для совместимости. Конечно, `null` не является объектом. Это специальное значение с отдельным типом.
# Преобразование типов данных
Чаще всего операторы и функции автоматически приводят переданные им значения к нужному типу, однако есть также случаи, когда нам нужно явно преобразовать значение в ожидаемый тип.

## Строковое преобразование
Mы можем использовать функцию String(value), чтобы преобразовать значение к строке:
```js
let value = true;
value = String(value); // теперь value это строка "true"
alert(typeof value); // string
```
Преобразование происходит очевидным образом. `false` становится `"false"`, `null` становится `"null"` и т.п.

## Численное преобразование
Численное преобразование происходит в математических функциях и выражениях.
Например, когда операция деления `/` применяется не к числу:
```js 
alert( "6" / "2" ); // 3, строки преобразуются в числа
```
Мы можем использовать функцию `Number(value)`, чтобы явно преобразовать `value` к числу:
```js
let str = "123";
alert(typeof str); // string

let num = Number(str); // становится числом 123

alert(typeof num); // number
```
Явное преобразование часто применяется, когда мы ожидаем получить число из строкового контекста, например из текстовых полей форм.

Если строка не может быть явно приведена к числу, то результатом преобразования будет `NaN`. Например:

```js
let age = Number("Любая строка вместо числа");

alert(age); // NaN, преобразование не удалось
```

|Значение|Преобразуется в…|
|---|---|
|`undefined`|`NaN`|
|`null`|`0`|
|`true / false`|`1` / `0`|
|`string`|Пробельные символы (пробелы, знаки табуляции `\t`, знаки новой строки `\n` и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем `0`, иначе из непустой строки «считывается» число. При ошибке результат `NaN`.|
```js 
alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN (ошибка чтения числа на месте символа "z")
alert( Number(true) );        // 1
alert( Number(false) );       // 0
```
Учтите, что null и undefined ведут себя по-разному. Так, null становится нулём, тогда как undefined приводится к NaN.

Большинство математических операторов также производит данное преобразование, как мы увидим в следующей главе.

# Логическое преобразование

^012d4d

Происходит в логических операциях, но также может быть выполнено явно с помощью функции `Boolean(value)`

Правило преобразования:
- Значения, которые интуитивно «пустые», вроде `0`, пустой строки, `null`, `undefined` и `NaN`, становятся `false`.
- Все остальные значения становятся `true`.
```js 
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("Привет!") ); // true
alert( Boolean("") ); // false
```


> [!NOTE] Заметим, что строка с нулём `"0"` — это `true`
> Некоторые языки (к примеру, PHP) воспринимают строку "0" как false. Но в JavaScript, если строка не пустая, то она всегда true.
> ```js
> alert( Boolean("0") ); // true
> alert( Boolean(" ") ); // пробел это тоже true (любая непустая строка это true)
> ```
	