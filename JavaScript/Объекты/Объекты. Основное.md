# Объекты
Из главы [[Типы данных и преобразования]] в JavaScript существует 8 типов данных. Семь из них называются `«примитивными»,` так как содержат только `одно` значение (будь то строка, число или что-то другое).

Объекты же используются `для хранения коллекций различных значений и более сложных сущностей`. В JavaScript объекты используются очень часто, это одна из основ языка.

Объект может быть создан с помощью фигурных скобок `{…}` с необязательным списком _свойств_. Свойство – это пара «ключ: значение», где `ключ` – это строка (также называемая «именем свойства»), а `значение` может быть чем угодно.
```js
// создание пустого объекта.

let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"
```

Обычно используют вариант с фигурными скобками `{...}`. Такое объявление называют _литералом объекта_ или _литеральной нотацией_.
## Литералы и свойства
При использовании литерального синтаксиса `{...}` мы сразу можем поместить в объект несколько свойств в виде пар «ключ: значение»:

```javascript
let user = {     // объект
  name: "John",  // под ключом "name" хранится значение "John"
  age: 30        // под ключом "age" хранится значение 30
};
```

У каждого свойства есть ключ (также называемый «имя» или «идентификатор»). После имени свойства следует двоеточие `":"`, и затем указывается значение свойства. Если в объекте несколько свойств, то они перечисляются через запятую.

В любой момент можно `добавить` в объект новые свойства,` удалить` или `прочитать` их содержимое.

Для обращения к свойствам используется запись «через точку»:
```javascript
// получаем свойства объекта:
alert( user.name ); // John
alert( user.age ); // 30
```

Добавление свойства с логическим значением:
```javascript
user.isAdmin = true;
```
Для удаления свойства используется оператор `delete`:
```javascript
delete user.age;
```

Последнее свойство объекта может заканчиваться запятой (это хороший тон написания кода):
```javascript
let user = {
  name: "John",
  age: 30,
}
```

Это называется «висячая запятая». Такой подход упрощает добавление, удаление и перемещение свойств, так как все строки объекта становятся одинаковыми.

> [!NOTE] Объект, объявленный как константа, может быть изменён
> Объект, объявленный через `const`, _может_ быть изменён.
> 
> Например:
> ```js
> const user = {
> 	name: "John"
> };
> user.name = "Pete"; // (*)
> alert(user.name); // Pete
> ```
> Может показаться, что строка `(*)` должна вызвать ошибку, но нет, здесь всё в порядке. Дело в том, что объявление `const` защищает от изменений только саму переменную `user`, а не её содержимое.
> 
> Определение `const` выдаст ошибку только если мы присвоим переменной другое значение: `user=...`.

## Квадратные скобки

Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки:
```javascript
let user = {
  name: "John",
  age: 30,
  "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
};
```

Однако обращение через точку вызовет ошибку, поэтому требуется использовать обращение с помощью `квадратных скобок`:
```js
let user = {};

// присваивание значения свойству
user["likes birds"] = true;

// получение значения свойства
alert(user["likes birds"]); // true

// удаление свойства
delete user["likes birds"];

// это вызовет синтаксическую ошибку
user.likes birds = true
```

> Точка требует, чтобы ключ был именован по правилам именования переменных. То есть не имел пробелов, не начинался с цифры и не содержал специальные символы, кроме `$` и `_`.

Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения. Например, имя свойства может храниться в переменной:
```javascript
let key = "likes birds";

// то же самое, что и user["likes birds"] = true;
user[key] = true;
```
Здесь переменная `key` может быть вычислена во время выполнения кода или зависеть от пользовательского ввода. После этого мы используем её для доступа к свойству. Это даёт нам большую гибкость.

Пример:
```javascript
let user = {
  name: "John",
  age: 30
};

let key = prompt("Что вы хотите узнать о пользователе?", "name");

// доступ к свойству через переменную
alert( user[key] ); // John (если ввели "name
```
### Вычисляемые свойства

Возможно использовать квадратные скобки в литеральной нотации для создания _вычисляемого свойства_.

Пример:
```javascript
let fruit = prompt("Какой фрукт купить?", "apple");

let bag = {
  [fruit]: 5, // имя свойства будет взято из переменной fruit
};

alert( bag.apple ); // 5, если fruit="apple"
```
Смысл вычисляемого свойства прост: запись `[fruit]` означает, что имя свойства необходимо взять из переменной `fruit`.

Так же можно `задать свойство` следующим образом:
```js
// имя свойства будет взято из переменной fruit
bag[fruit] = 5;
```
Возможно использование и более сложные выражения в квадратных скобках:
```javascript
let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
```
Квадратные скобки дают намного больше возможностей, чем запись через точку. Они позволяют использовать любые имена свойств и переменные, хотя и требуют более громоздких конструкций кода.

## Свойство из переменной
В реальном коде часто нам необходимо использовать существующие переменные как значения для свойств с тем же именем.

Самый прямой способ - сделать функцию, которая превратит переменные в объект:
```js
function makeUser(name, age) {
  return {
    name: name,
    age: age
    // ...другие свойства
  };
}

let user = makeUser("John", 30);
alert(user.name); // John
```

Однако при написание кода часто возникает нужда в подобном преобразовании, поэтому можно обойтись сделать пример короче. Вместо `name:name` мы можем написать просто `name`:
```js
function makeUser(name, age) {
  return {
    name, // то же самое, что и name: name
    age   // то же самое, что и age: age
    // ...
  };
}
```
Возможно использовать как обычные свойства, так и короткие в одном и том же объекте:
```javascript
let user = {
  name,  // тоже самое, что и name:name
  age: 30
};
```
## Ограничения на имена свойств

Имя переменной не может совпадать с зарезервированными словами, такими как «for», «let», «return» и т.д.

Но для свойств объекта такого ограничения нет:
```js
// эти имена свойств допустимы
let obj = {
  for: 1,
  let: 2,
  return: 3
};

alert( obj.for + obj.let + obj.return );  // 6
```
Иными словами, нет никаких ограничений к именам свойств. Они могут быть в виде строк или символов (специальный тип для идентификаторов, который будет рассмотрен позже).

Все другие типы данных будут автоматически преобразованы к строке.

Например, если использовать число `0` в качестве ключа, то оно превратится в строку `"0"`:
```javascript
let obj = {
  0: "Тест" // то же самое что и "0": "Тест"
};

// обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
alert( obj["0"] ); // Тест
alert( obj[0] ); // Тест (то же свойство)
```

## Проверка существования свойства, оператор «in»

В отличие от многих других языков, особенность JavaScript-объектов в том, что можно получить доступ к любому свойству. Даже если свойства не существует – ошибки не будет!

При обращении к свойству, которого нет, возвращается `undefined`. Это позволяет просто проверить существование свойства:
```javascript
let user = {};

alert( user.noSuchProperty === undefined ); // true означает "свойства нет"
```
Также существует специальный оператор `"in"` для проверки существования свойства в объекте.

Синтаксис оператора:
```javascript
"key" in object
```
Пример:
```javascript
let user = { name: "John", age: 30 };

alert( "age" in user ); // true, user.age существует
alert( "blabla" in user ); // false, user.blabla не существует
```

`Слева от оператора` `in` должно быть _имя свойства_. Обычно это строка в кавычках.

Если мы `опускаем кавычки`, это значит, что мы *указываем переменную*, в которой находится имя свойства. Например:
```javascript
let user = { age: 30 };

let key = "age";
alert( key in user ); // true, имя свойства было взято из переменной key
```
В большинстве случаев прекрасно сработает сравнение с `undefined`. Но есть особый случай, когда оно не подходит и нужно использовать `"in"`.

Это когда свойство существует, но содержит значение `undefined`:
```javascript
let obj = {
  test: undefined
};

alert( obj.test ); //  выведет undefined, значит свойство не существует?
alert( "test" in obj ); // true, свойство существует!
```

В примере выше свойство `obj.test` технически существует в объекте. Оператор `in` сработал правильно.

Подобные ситуации случаются очень редко, так как `undefined` обычно явно не присваивается. Для «неизвестных» или «пустых» свойств мы используем значение `null`.

## Цикл "for..in"

Для перебора всех свойств объекта используется цикл `for..in`. Этот цикл отличается от изученного ранее цикла `for(;;)`.

Синтаксис:
```javascript
for (key in object) {
  // тело цикла выполняется для каждого свойства объекта
}
```

К примеру, давайте выведем все свойства объекта `user`:
```javascript
let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
```
### Упорядочение свойств объекта

***Если мы будем в цикле перебирать все свойства объекта, получим ли мы их в том же порядке, в котором мы их добавляли? Можем ли мы на это рассчитывать?***

Короткий ответ: свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания. Разберёмся подробнее.

В качестве примера рассмотрим объект с телефонными кодами:
```javascript
let codes = {
  "49": "Германия",
  "41": "Швейцария",
  "44": "Великобритания",
  // ..,
  "1": "США"
};

for (let code in codes) {
  alert(code); // 1, 41, 44, 49
}
```


> [!NOTE] Целочисленные свойства? Это что?
> Термин «целочисленное свойство» означает строку, которая может быть преобразована в целое число и обратно без изменений.
> 
> То есть, `"49"` – это целочисленное имя свойства, потому что если его преобразовать в целое число, а затем обратно в строку, то оно не изменится. А вот свойства `"+49"` или `"1.2"` таковыми не являются:
> ```js
> // Math.trunc - встроенная функция, которая удаляет десятичную часть
> alert( String(Math.trunc(Number("49"))) ); 
> // "49", то же самое ⇒ свойство целочисленное
> alert( String(Math.trunc(Number("+49"))) ); 
> // "49", не то же самое, что "+49" ⇒ свойство не целочисленное
> alert( String(Math.trunc(Number("1.2"))) ); 
> // "1", не то же самое, что "1.2" ⇒ свойство не целочисленное
> ```

…С другой стороны, если ключи не целочисленные, то они перебираются в порядке создания, например:
```javascript
let user = {
  name: "John",
  surname: "Smith"
};
user.age = 25; // добавим ещё одно свойство

// не целочисленные свойства перечислены в порядке создания
for (let prop in user) {
  alert( prop ); // name, surname, age
```