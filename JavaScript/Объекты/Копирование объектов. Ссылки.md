Одно из фундаментальных отличий объектов от примитивов заключается в том, что объекты хранятся и копируются «по ссылке», тогда как примитивные значения: строки, числа, логические значения и т.д. – всегда копируются «как целое значение».

Здесь мы помещаем копию `message` во `phrase`:
```javascript
let message = "Привет!";
let phrase = message;
```

Объекты ведут себя иначе.

**Переменная, которой присвоен объект, хранит не сам объект, а его «адрес в памяти» – другими словами, «ссылку» на него.**

Объект хранится где-то в памяти, в то время как переменная `user` имеет лишь «ссылку» на него.

**При копировании переменной объекта копируется ссылка, но сам объект не дублируется.**

Например:
```javascript
let user = { name: "John" };

let admin = user; // копируется ссылка
```

Все ещё есть один объект, но теперь с двумя переменными, которые ссылаются на него.

Мы можем использовать любую переменную для доступа к объекту и изменения его содержимого:
```javascript
let user = { name: 'John' };

let admin = user;

admin.name = 'Pete'; // изменено по ссылке из переменной "admin"

alert(user.name); // 'Pete', изменения видны по ссылке из переменной "user"
```

## Сравнение по ссылке

Два объекта равны только в том случае, если это один и тот же объект.
Например, здесь `a` и `b` ссылаются на один и тот же объект, поэтому они равны:
```js
let a = {};
let b = a; // копирование по ссылке

alert( a == b ); // true, обе переменные ссылаются на один и тот же объект
alert( a === b ); // true
```
И здесь два независимых объекта не равны, даже если они выглядят одинаково (оба пусты):
```javascript
let a = {};
let b = {}; // два независимых объекта

alert( a == b ); // false
```
## Клонирование и объединение, Object.assign
Клонирование немного сложнее, чем копирование ссылки, потому что в JavaScript для этого нет встроенного метода. Но на самом деле в этом редко возникает необходимость, копирования по ссылке в большинстве случаев вполне хватает.****

Но если мы действительно этого хотим, то нам нужно создать новый объект и воспроизвести структуру существующего, перебрав его свойства и скопировав их на примитивном уровне.

```javascript
let user = {
  name: "John",
  age: 30
};

let clone = {}; // новый пустой объект

// давайте скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}

// теперь clone это полностью независимый объект с тем же содержимым
clone.name = "Pete"; // изменим в нём данные

alert( user.name ); // все ещё John в первоначальном объекте
```

Также мы можем использовать для этого метод [Object.assign](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign).
Синтаксис:
```javascript
Object.assign(dest, [src1, src2, src3...])
```
- Первый аргумент `dest` — целевой объект.
- Остальные аргументы `src1, ..., srcN` (может быть столько, сколько необходимо) являются исходными объектами
- Метод копирует свойства всех исходных объектов `src1, ..., srcN` в целевой объект `dest`. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
- Возвращает объект `dest`.
- 
Например, мы можем использовать его для объединения нескольких объектов в один:
```javascript
let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);

// теперь user = { name: "John", canView: true, canEdit: true }
```

Если скопированное имя свойства уже существует, оно будет перезаписано:

```javascript
let user = { name: "John" };

Object.assign(user, { name: "Pete" });

alert(user.name); // теперь user = { name: "Pete" }
```

Мы также можем использовать `Object.assign` для замены цикла `for..in` для простого клонирования:

```javascript
let user = {
  name: "John",
  age: 30
};

let clone = Object.assign({}, user);
```
Он копирует все свойства `user` в пустой объект и возвращает его.

## Вложенное клонирование 
До сих пор мы предполагали, что все свойства `user` примитивныe. Но свойства могут быть и ссылками на другие объекты. Что с ними делать?

Например, есть объект:
```js
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

alert( user.sizes.height ); // 182
```
Теперь недостаточно просто скопировать `clone.sizes = user.sizes`, потому что `user.sizes` – это объект, он будет скопирован по ссылке. Таким образом, `clone` и `user` будут иметь общий объект `sizes`:
```javascript
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, тот же объект

// user и clone обладают общим свойством sizes
user.sizes.width++;       // изменяем свойства в первом объекте
alert(clone.sizes.width); // 51, видим результат в другом
```
Чтобы исправить это, мы должны использовать цикл клонирования, который проверяет каждое значение `user[key]` и, если это объект, тогда также копирует его структуру. Это называется «глубоким клонированием».

Мы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы не изобретать велосипед заново, возьмите готовую реализацию, например [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep) из библиотеки JavaScript [lodash](https://lodash.com/).

Также мы можем использовать глобальный метод [structuredClone()](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone), который позволяет сделать полную копию объекта. К сожалению он поддерживается только современными браузерами. [Здесь](https://caniuse.com/?search=structuredClone) можно ознакомиться с поддержкой этого метода.
> [!NOTE] Объекты, объявленные как константа, могут быть изменены
> Важным побочным эффектом хранения объектов в качестве ссылок является то, что объект, объявленный как `const`, _может_ быть изменён.
> 
> Может показаться, что строка `(*)` вызовет ошибку, но, это не так. Значение `user` это константа, оно всегда должно ссылаться на один и тот же объект, но свойства этого объекта могут свободно изменяться.
> 
> Другими словами, `const user` выдаст ошибку только в том случае, если мы попытаемся задать `user=...` в целом.


